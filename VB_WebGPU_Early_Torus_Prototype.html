<!--

   Copyright 2025 Johnny Mongstad

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>WebGPU — Early Prototype - Recursive Toroidal Hologram: Nested Boundary Encoding</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body { margin:0; background:#0b0f14; color:#cbd5e1; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; }
  #row { display:flex; height:100vh; width=100vw; }
  #gfx { flex:1; position:relative; }
  #gfx canvas { position:absolute; inset:0; width=100%; height=100%; display:block; }
  #overlay { pointer-events:none; }
  #hud { position:absolute; top:10px; right:10px; background:rgba(15,23,42,.75); border:1px solid rgba(148,163,184,.25); border-radius:12px; padding:10px 12px; backdrop-filter: blur(6px); font-size:12px; }
  #ui { width:380px; padding:14px; overflow:auto; border-left:1px solid #1f2937; background:linear-gradient(180deg,#0f172a,#0b1220); }
  h1 { font-size:14px; margin:4px 0 12px; color:#93c5fd; }
  .row { margin:12px 0; }
  .row label { display:flex; justify-content:space-between; font-size:12px; margin-bottom:6px; }
  .row input[type="range"] { width:100%; }
  .small { opacity:.75; font-size:11px; }
  .pill { background:#0b1220; border:1px solid #1f2a40; border-radius:999px; padding:.25rem .6rem; display:inline-flex; gap:.5rem; align-items:center; }
  .switch { display:flex; align-items:center; gap:.5rem; }
  #err { color:#f87171; white-space:pre-wrap; }
</style>

<style>
  .collapsed #ui { display: none; }
  .collapsed #gfx { flex: 1 1 100%; }
  #collapseBtn {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    background: rgba(15,23,42,.75); color: #cbd5e1; border: 1px solid rgba(148,163,184,.25);
    border-radius: 6px; padding: 4px 8px; cursor: pointer;
    backdrop-filter: blur(6px);
  }
</style>


<!-- Inline JWST points (scaled) -->
<script id="jwst_inline" type="application/json">[
  {"id":"GAL-5315-2778","p":[3.183713727095898,-2.7961427288037095,4.248005737291239],"z_redshift":12.926},
  {"id":"GAL-0357-3040","p":[5.164950617507547,-3.0363461958880293,0.3223149041305664],"z_redshift":12.908},
  {"id":"GAL-5317-2782","p":[3.181173944346363,-2.8003168135792023,4.247158824366876],"z_redshift":12.516},
  {"id":"GAL-0351-3036","p":[5.167638000401501,-3.032299802158718,0.3172938805501451],"z_redshift":12.393},
  {"id":"GAL-5316-2777","p":[3.1826643597316115,-2.7959694659667873,4.2489060143377575],"z_redshift":11.552},
  {"id":"GAL-2149-5294","p":[-2.963866158271505,4.788183101017339,-2.0709418115883653],"z_redshift":11.4},
  {"id":"GAL-2149-5295","p":[-2.964975843627268,4.788376198268935,-2.0689059018134004],"z_redshift":11.04},
  {"id":"GAL-2149-5284","p":[-2.9711527271124205,4.781829166852763,-2.0751774119840074],"z_redshift":10.81},
  {"id":"GAL-2149-5290","p":[-2.969404868007833,4.785794129374798,-2.0685282886857292],"z_redshift":10.619},
  {"id":"GAL-5316-2777b","p":[3.183137451536948,-2.7958638390327355,4.248621112574289],"z_redshift":10.38}
]</script>

<script id="jwst_stats" type="application/json">{
  "count":10, "z_redshift_min":10.38, "z_redshift_max":12.926, "radius_display_units":6.0
}</script>
</head>

<body>
  <button id="collapseBtn">☰</button>

<div id="row">
  <div id="gfx">
    <canvas id="c"></canvas>
    <canvas id="overlay"></canvas>
    <div id="hud">GPU: <span id="gpu">—</span> • fps: <span id="fps">—</span><br>Phase: <span id="phase">—</span> • Audio: <span id="aust">off</span></div>
  </div>
  <div id="ui">
    <h1>Recursive Toroidal Hologram (Nested Boundary Encoding)</h1>
    <div class="small">Nested tori with interactive frequency feeding for patterns.</div>

    <div class="row"><label>Major radius R <span id="Rval"></span></label><input id="R" type="range" min="0.8" max="4.0" step="0.01" value="1.8"></div>
    <div class="row"><label>Minor radius r <span id="rval"></span></label><input id="r" type="range" min="0.10" max="1.20" step="0.01" value="0.45"></div>
    <div class="row"><label>Tilt (rad) <span id="tiltval"></span></label><input id="tilt" type="range" min="-1.2" max="1.2" step="0.01" value="0.35"></div>
    <div class="row"><label>Child shift X <span id="shiftval"></span></label><input id="shift" type="range" min="-3.0" max="3.0" step="0.01" value="1.6"></div>
    <div class="row"><label>Smooth‑union k <span id="kval"></span></label><input id="k" type="range" min="0.00" max="0.80" step="0.005" value="0.25"></div>
    <div class="row"><label>Exposure <span id="expval"></span></label><input id="exp" type="range" min="0.5" max="3.0" step="0.01" value="1.25"></div>
    <div class="row"><label>Recursion Depth <span id="depthval"></span></label><input id="depth" type="range" min="1" max="5" step="1" value="1"></div>

    <div class="row switch"><input id="proj" type="checkbox"><label for="proj" class="pill">Projection: Sphere</label></div>
    <div class="row switch"><input id="jwst" type="checkbox" checked><label for="jwst" class="pill">Show JWST overlay (direct)</label></div>
    <div class="row switch"><input id="field" type="checkbox" checked><label for="field" class="pill">Show energy field (direct)</label></div>
    <div class="row switch"><input id="holo" type="checkbox"><label for="holo" class="pill">Hologram mode (boundary → interior)</label></div>

    <div class="row switch"><input id="showTorus" type="checkbox" checked><label for="showTorus" class="pill">Show tori (geometry)</label></div>

    <div class="row switch"><input id="mute" type="checkbox"><label for="mute" class="pill">Mute audio</label></div>
    <div class="row small">Controls: WASD move • mouse drag look • Q/E down/up • Shift faster • O toggles auto‑orbit. Hologram mode puts camera inside the throat.</div>
    <div id="err" class="row"></div>
  </div>
</div>

<script>
(async ()=>{
  const $=id=>document.getElementById(id);
  const err = m => $('err').textContent = m;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  if(!('gpu' in navigator)){ err('WebGPU not available. Use Chrome/Edge 113+ with WebGPU.'); return; }

  // --- Data ---
  const JWST_RAW = JSON.parse($('jwst_inline').textContent);
  const JWST_STATS = JSON.parse($('jwst_stats').textContent);
  const jwst = JWST_RAW.map(d=>({p:d.p, z:d.z_redshift}));

  // --- DOM ---
  const canvas=$('c'), overlay=$('overlay');
  const R_=$('R'), r_=$('r'), tilt_=$('tilt'), shift_=$('shift'), k_=$('k'), exp_=$('exp'), depth=$('depth');
  const Rval=$('Rval'), rval=$('rval'), tiltval=$('tiltval'), shiftval=$('shiftval'), kval=$('kval'), expval=$('expval'), depthval=$('depthval');
  const jwstToggle=$('jwst'), fieldToggle=$('field'), holoToggle=$('holo'), showTorus=$('showTorus');
  const projToggle=$('proj'); const fpsEl=$('fps'), phaseEl=$('phase'), austEl=$('aust');

  function sync(){ Rval.textContent=(+R_.value).toFixed(2); rval.textContent=(+r_.value).toFixed(2);
    tiltval.textContent=(+tilt_.value).toFixed(2); shiftval.textContent=(+shift_.value).toFixed(2);
    kval.textContent=(+k_.value).toFixed(3); expval.textContent=(+exp_.value).toFixed(2); depthval.textContent=(+depth.value).toFixed(0);
  }
  ['input','change'].forEach(ev=>[R_,r_,tilt_,shift_,k_,exp_,depth,projToggle,holoToggle,showTorus].forEach(e=>e.addEventListener(ev,sync))); sync();

  // --- GPU setup ---
  const adapter = await navigator.gpu.requestAdapter(); if(!adapter){err('No adapter');return;}
  const device = await adapter.requestDevice();
  const ctx = canvas.getContext('webgpu'); const format = navigator.gpu.getPreferredCanvasFormat();
  ctx.configure({device:device, format, alphaMode:'premultiplied'}); $('gpu').textContent = adapter.name || 'GPU';

  function fit(){
    const dpr=Math.min(2,window.devicePixelRatio||1), host=$('gfx');
    const w=canvas.clientWidth=host.clientWidth, h=canvas.clientHeight=host.clientHeight;
    canvas.width=Math.max(1,Math.floor(w*dpr)); canvas.height=Math.max(1,Math.floor(h*dpr));
    overlay.width=canvas.width; overlay.height=canvas.height;
  }
  new ResizeObserver(fit).observe($('gfx')); fit();

  // --- Math helpers ---
  const v3=(x,y,z)=>[x,y,z]; const add=(a,b)=>v3(a[0]+b[0],a[1]+b[1],a[2]+b[2]);
  const sub=(a,b)=>v3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);
  const mul=(a,s)=>v3(a[0]*s,a[1]*s,a[2]*s);
  const norm=a=>{const L=Math.hypot(a[0],a[1],a[2])||1; return v3(a[0]/L,a[1]/L,a[2]/L);};
  const dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
  const cross=(a,b)=>v3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]);
  function rotXv(a, v){
    const c=Math.cos(a), s=Math.sin(a);
    return [v[0], c*v[1] - s*v[2], s*v[1] + c*v[2]];
  }

  // --- WGSL (adds hologram sampling) ---
  const shader = device.createShaderModule({code:/* wgsl */`
struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32>, };
@vertex
fn vsMain(@builtin(vertex_index) vid: u32) -> VSOut {
  var p = array<vec2<f32>,3>( vec2<f32>(-1.,-3.), vec2<f32>(3.,1.), vec2<f32>(-1.,1.) );
  var o:VSOut; o.pos=vec4<f32>(p[vid],0.,1.); o.uv=(p[vid]*0.5)+vec2<f32>(0.5); return o;
}
struct Params { v0:vec4<f32>, v1:vec4<f32>, v2:vec4<f32>, v3:vec4<f32>, v4:vec4<f32>, v5:vec4<f32> };
@group(0) @binding(0) var<uniform> P: Params;
@group(0) @binding(1) var holoTex: texture_2d<f32>;
@group(0) @binding(2) var holoSamp: sampler;

fn sdTorus(p:vec3<f32>, R:f32, r:f32)->f32{ let q=vec2<f32>(length(p.xz)-R, p.y); return length(q)-r; }
fn sdSphere(p:vec3<f32>, R:f32)->f32{ return length(p)-R; }
fn rotX(a:f32)->mat3x3<f32>{ let c=cos(a); let s=sin(a);
  return mat3x3<f32>( vec3<f32>(1.,0.,0.), vec3<f32>(0.,c,-s), vec3<f32>(0.,s,c) ); }
fn opSmoothUnion(d1:f32,d2:f32,k:f32)->f32{ let h=clamp(0.5+0.5*(d2-d1)/max(k,1e-4),0.,1.); return mix(d2,d1,h)-k*h*(1.-h); }

fn map_torus(p:vec3<f32>)->f32{
  let R=P.v2.w; let r=P.v3.w; let k=P.v4.w; let tilt=P.v5.x; let shiftX=P.v5.y;
  var pa=p; pa=rotX(tilt)*pa; let dA=sdTorus(pa,R,r);
  let pb=p-vec3<f32>(shiftX,0.,0.);
  let dB=sdTorus(pb,R*0.67,max(0.1,r*0.78));
  let dShell=abs(sdTorus(p,R*1.95,r*1.33))-0.02;
  var d=opSmoothUnion(dA,dB,k); d=min(d,dShell); return d;
}
fn map(p:vec3<f32>)->f32{ let proj=P.v5.z; if(proj>0.5){return sdSphere(p,P.v2.w);} return map_torus(p); }

fn calcNormal(p:vec3<f32>)->vec3<f32>{
  let e=0.001;
  let dx=map(p+vec3<f32>( e,0,0))-map(p+vec3<f32>(-e,0,0));
  let dy=map(p+vec3<f32>(0, e,0))-map(p+vec3<f32>(0,-e,0));
  let dz=map(p+vec3<f32>(0,0, e))-map(p+vec3<f32>(0,0,-e));
  return normalize(vec3<f32>(dx,dy,dz));
}
fn tonemap(c:vec3<f32>,ex:f32)->vec3<f32>{ let x=c*ex; return x/(1.+x); }

fn torusUV(p:vec3<f32>, R:f32)->vec2<f32>{
  let phi = atan2(p.z,p.x); // [-pi,pi]
  let minor = vec2<f32>(length(p.xz)-R, p.y);
  let theta = atan2(minor.y, minor.x);
  return vec2<f32>((phi+3.14159265)/(2.0*3.14159265), (theta+3.14159265)/(2.0*3.14159265));
}

@fragment
fn fsMain(@location(0) uv:vec2<f32>) -> @location(0) vec4<f32>{
  let camPos = P.v0.xyz; let time=P.v0.w;
  let camDir = normalize(P.v1.xyz); let exposure=P.v1.w;
  let camRight = normalize(P.v2.xyz); let R=P.v2.w;
  let camUp = normalize(P.v3.xyz); let r=P.v3.w;
  let light = P.v4.xyz;
  let flags = P.v5;

  let ndc=uv*2.0-vec2<f32>(1.,1.);
  let dims = textureDimensions(holoTex,0);
  let aspect_fix = f32(dims.x)/f32(dims.y);
  let f = 1.0 / tan(0.5 * radians(55.0));
  var rd = normalize(camDir*f + camRight*ndc.x*aspect_fix + camUp*ndc.y);
  var ro = camPos;

  var color = vec3<f32>(0.02,0.03,0.05);
  var hit = false;

  if (flags.w > 0.5) {
    var t: f32 = 0.0;
    for (var i:i32=0; i<96; i=i+1){
      let p = ro + rd*t;
      let d = abs(sdTorus(p, R*1.95, r*1.33)) - 0.02;
      if (d < 5e-3) {
        let uvT = torusUV(p, R*1.95);
        let tex = textureSampleLevel(holoTex, holoSamp, uvT, 0.0);
        color = mix(color, tex.rgb, 0.85);
        hit = true; break;
      }
      t = t + max(d, 0.02);
      if (t>80.0) { break; }
    }
    /* removed fallback hologram sampling to avoid background noise */
    return vec4<f32>(pow(tonemap(color, exposure), vec3<f32>(1.0/2.2)), 1.0);
  }

  var t: f32 = 0.0;
  for (var i:i32=0; i<128; i=i+1){
    let p = ro + rd*t;
    let d = map(p);
    if (d < 1e-4){
      let n = calcNormal(p);
      let l = normalize(light - p);
      let diff = max(dot(n,l), 0.0);
      var base = vec3<f32>(0.13,0.30,0.55);
      color = base*(0.2 + 0.8*diff);
      let U = atan2(p.z,p.x);
      let V = atan2(p.y, max(1e-5, length(p.xz) - (R*1.95)));
      color += 0.12*vec3<f32>(0.4,0.8,1.0)*(0.5+0.5*sin(12.0*U+0.7*time))*(0.5+0.5*sin(8.0*V));
      hit=true; break;
    }
    t = t + d; if (t>60.0){ break; }
  }
  /* removed fallback hologram sampling to avoid background noise */
  return vec4<f32>(pow(tonemap(color,exposure), vec3<f32>(1.0/2.2)),1.0);
}
`});

  // --- Pipeline ---
  const pipeline = device.createRenderPipeline({
    layout:'auto',
    vertex:{module:shader, entryPoint:'vsMain'},
    fragment:{module:shader, entryPoint:'fsMain', targets:[{format}]},
    primitive:{topology:'triangle-list'}
  });

  // --- Uniforms ---
  const UBO_SIZE = 6*16;
  const ubo = device.createBuffer({size:UBO_SIZE, usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});

  // --- Hologram texture & sampler (updated each frame from CPU)
  const HOLO_W = 1024, HOLO_H = 512;
  let holoTex = device.createTexture({
    size:[HOLO_W, HOLO_H], format:'rgba8unorm',
    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
  });
  const holoSampler = device.createSampler({ addressModeU:'repeat', addressModeV:'repeat', magFilter:'linear', minFilter:'linear' });

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      {binding:0, resource:{buffer:ubo}},
      {binding:1, resource:holoTex.createView()},
      {binding:2, resource:holoSampler}
    ]
  });

  // --- Camera + controls ---
  const state={ camPos:[0,0,5], yaw:-Math.PI, pitch:0.0, speed:4.0 };
  let autoOrbit=true; const orbitSpeed=0.08;
  const keys=new Set(); window.addEventListener('keydown',e=>{const k=e.key.toLowerCase(); keys.add(k); if(e.key==='Shift')state.speed=8; if(k==='o')autoOrbit=!autoOrbit;});
  window.addEventListener('keyup',e=>{keys.delete(e.key.toLowerCase()); if(e.key==='Shift')state.speed=4;});
  let dragging=false, lastX=0,lastY=0;
  canvas.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY; ensureAudio(); autoOrbit=false;});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{ if(!dragging)return; const dx=(e.clientX-lastX)*0.003, dy=(e.clientY-lastY)*0.003; state.yaw+=dx; state.pitch=clamp(state.pitch+dy,-1.2,1.2); lastX=e.clientX; lastY=e.clientY; },{passive:true});
  function camBasis(){
    const cy=Math.cos(state.yaw), sy=Math.sin(state.yaw); const cp=Math.cos(state.pitch), sp=Math.sin(state.pitch);
    const forward=norm([-cy*cp, sp, -sy*cp]); const right=norm([sy,0,-cy]); const up=cross(right,forward);
    return {forward,right,up};
  }

  // --- JWST bounds for framing & field extent ---
  function bounds(points){ const n=points.length||1; let cx=0,cy=0,cz=0; for(const s of points){ cx+=s.p[0]; cy+=s.p[1]; cz+=s.p[2]; }
    cx/=n; cy/=n; cz/=n; let r=0; for(const s of points){ const dx=s.p[0]-cx,dy=s.p[1]-cy,dz=s.p[2]-cz; r=Math.max(r,Math.hypot(dx,dy,dz)); }
    return {center:[cx,cy,cz], radius:r};
  }
  const {center:JW_C, radius:JW_R}=bounds(jwst);

  const FOV = 55*Math.PI/180;
  function lookAt(from,to){ const q=sub(to,from), f=norm(q); state.yaw=Math.atan2(-f[2],-f[0]); state.pitch=clamp(Math.asin(f[1]),-1.2,1.2); }
  function frameAll(pad=1.35){ const torusExtent=(+R_.value + +r_.value*2.0); const B=Math.max(JW_R, torusExtent);
    const dist=(B*pad)/Math.tan(FOV*0.5); const from=add(JW_C,[dist,dist*0.15,dist*0.35]); lookAt(from,JW_C); state.camPos=from; }
  frameAll();

  // --- Energy field (as before) ---
  let FIELD_MAX_R = Math.max(JW_R*1.15, (+R_.value)*8.0);
  const FIELD={N:8000, pos:new Float32Array(8000*3), vel:new Float32Array(8000*3), life:new Float32Array(8000)};
  function seed(i){
    const u=Math.random()*Math.PI*2; const Rmaj=+R_.value, rmin=+r_.value; const ringR=Math.max(0.05, Rmaj-0.5*rmin);
    const x=ringR*Math.cos(u), z=ringR*Math.sin(u), y=(Math.random()*2-1)*0.15*rmin;
    FIELD.pos[i*3]=x; FIELD.pos[i*3+1]=y; FIELD.pos[i*3+2]=z;
    const radial=norm([x,y*0.35,z]); const swirl=norm(cross([0,1,0],radial));
    const vmag=0.9+Math.random()*0.6, swirlAmt=1.2;
    FIELD.vel[i*3]=radial[0]*vmag+swirl[0]*swirlAmt;
    FIELD.vel[i*3+1]=radial[1]*vmag+swirl[1]*swirlAmt;
    FIELD.vel[i*3+2]=radial[2]*vmag+swirl[2]*swirlAmt;
    FIELD.life[i]=Math.random()*0.5;
  }
  for(let i=0;i<FIELD.N;i++)seed(i);
  function advect(dt){
    const drag=0.996;
    for(let i=0;i<FIELD.N;i++){
      const ix=i*3; let px=FIELD.pos[ix], py=FIELD.pos[ix+1], pz=FIELD.pos[ix+2];
      let vx=FIELD.vel[ix], vy=FIELD.vel[ix+1], vz=FIELD.vel[ix+2];
      const r=Math.hypot(px,py,pz)+1e-6; const radial=[px/r,py/r,pz/r]; const swirl=norm(cross([0,1,0],radial));
      const accR=0.05/(0.15+r*r), accS=0.12/(0.3+r), jitter=0.015;
      vx+=radial[0]*accR+swirl[0]*accS+(Math.random()*2-1)*jitter*dt;
      vy+=radial[1]*accR+swirl[1]*accS+(Math.random()*2-1)*jitter*dt;
      vz+=radial[2]*accR+swirl[2]*accS+(Math.random()*2-1)*jitter*dt;
      vx*=drag; vy*=drag; vz*=drag; px+=vx*dt; py+=vy*dt; pz+=vz*dt;
      FIELD.pos[ix]=px; FIELD.pos[ix+1]=py; FIELD.pos[ix+2]=pz; FIELD.vel[ix]=vx; FIELD.vel[ix+1]=vy; FIELD.vel[ix+2]=vz;
      FIELD.life[i]+=dt; if(r>FIELD_MAX_R || FIELD.life[i]>12.0) seed(i);
    }
  }

  // --- Boundary encoder (CPU → texture) ---
  const holoCanvas=document.createElement('canvas'); holoCanvas.width=HOLO_W; holoCanvas.height=HOLO_H;
  const holo2d=holoCanvas.getContext('2d', { willReadFrequently: true });
  function torusUV(p, R){ const phi=Math.atan2(p[2],p[0]); const minor=[Math.hypot(p[0],p[2])-R, p[1]];
    const theta=Math.atan2(minor[1], minor[0]);
    const u=(phi+Math.PI)/(2*Math.PI); const v=(theta+Math.PI)/(2*Math.PI); return [u,v];
  }

  function encodeBoundary(){
    const tilt = +tilt_.value;
    holo2d.fillStyle='rgba(0,0,0,0.12)'; holo2d.fillRect(0,0,HOLO_W,HOLO_H);

    const Rmaj=+R_.value; const rmin=+r_.value;
    for(let i=0;i<FIELD.N;i++){
      const x=FIELD.pos[i*3], y=FIELD.pos[i*3+1], z=FIELD.pos[i*3+2];
      const [u,v]=torusUV(rotXv(tilt,[x,y,z]), Rmaj*1.95);
      const r=Math.hypot(x,y,z); const t=clamp(r/FIELD_MAX_R,0,1);
      const Rcol=Math.floor(255*Math.pow(t,1.2)), Gcol=Math.floor(200*Math.min(1,0.6+t*0.6)), Bcol=Math.floor(255*(1-t*0.8));
      holo2d.fillStyle=`rgba(${Rcol},${Gcol},${Bcol},0.25)`;
      holo2d.fillRect((u*HOLO_W)|0, (v*HOLO_H)|0, 2, 2);
    }
    const zMin=JWST_STATS.z_redshift_min, zMax=JWST_STATS.z_redshift_max, zDen=Math.max(1e-6, zMax-zMin);
    for(const g of jwst){
      const [u,v]=torusUV(rotXv(tilt, g.p), Rmaj*1.95);
      const t=clamp((g.z - zMin)/zDen, 0, 1);
      const r=Math.floor(255*t), gg=Math.floor(180*(1-Math.abs(t-0.5)*2)), b=Math.floor(255*(1-t));
      holo2d.fillStyle=`rgba(${r},${gg},${b},0.9)`;
      holo2d.fillRect((u*HOLO_W-2)|0, (v*HOLO_H-2)|0, 4, 4);
    }

    const img = holo2d.getImageData(0,0,HOLO_W,HOLO_H);
    device.queue.writeTexture({texture:holoTex}, img.data, {bytesPerRow:HOLO_W*4}, [HOLO_W,HOLO_H]);
  }

  // --- Overlay (direct-mode only) ---
  function projectToScreen(world, camPos, basis, aspect, fovRad){
    const q=[world[0]-camPos[0], world[1]-camPos[1], world[2]-camPos[2]];
    const xc=dot(q,basis.right), yc=dot(q,basis.up), zc=dot(q,basis.forward); if(zc<=0.001) return null;
    const f=1/Math.tan(0.5*fovRad); const xndc=(xc*f)/(zc*aspect); const yndc=(yc*f)/zc;
    const x=(xndc*0.5+0.5)*overlay.width, y=(1-(yndc*0.5+0.5))*overlay.height; return [x,y,zc];
  }
  function drawOverlay(){
    const ctx=overlay.getContext('2d'); ctx.clearRect(0,0,overlay.width,overlay.height);
    if (holoToggle.checked) return;
    const {forward,right,up}=camBasis(); const aspect=overlay.width/overlay.height; const FOVr=55*Math.PI/180;
    const tilt = +tilt_.value;

    if (fieldToggle.checked){
      const baseA=0.12;
      for(let i=0;i<FIELD.N;i++){
        const ix=i*3; const s=projectToScreen(rotXv(tilt,[FIELD.pos[ix],FIELD.pos[ix+1],FIELD.pos[ix+2]]), state.camPos, {forward,right,up}, aspect, FOVr);
        if(!s) continue; const [x,y,zc]=s; const r=Math.hypot(FIELD.pos[ix],FIELD.pos[ix+1],FIELD.pos[ix+2]); const t=clamp(r/FIELD_MAX_R,0,1);
        const size=clamp(3/(0.15+zc*0.06),1,4); const Rcol=Math.floor(255*Math.pow(t,1.2)), Gcol=Math.floor(200*Math.min(1,0.6+t*0.6)), Bcol=Math.floor(255*(1-t*0.8));
        ctx.fillStyle=`rgba(${Rcol},${Gcol},${Bcol},${baseA})`; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
      }
    }
    if (jwstToggle.checked){
      const zMin=JWST_STATS.z_redshift_min, zMax=JWST_STATS.z_redshift_max, zDen=Math.max(1e-6, zMax-zMin);
      for(const g of jwst){
        const s=projectToScreen(rotXv(tilt, g.p), state.camPos, {forward,right,up}, aspect, FOVr);
        if(!s) continue; const [x,y,zc]=s;
        const t=clamp((g.z - zMin)/zDen, 0, 1);
        const r=Math.floor(255*t), gg=Math.floor(180*(1-Math.abs(t-0.5)*2)), b=Math.floor(255*(1-t));
        const size=clamp(6/(0.2+zc*0.05),2,8);
        const grad=ctx.createRadialGradient(x,y,0,x,y,size*2);
        grad.addColorStop(0,`rgba(${r},${gg},${b},0.9)`); grad.addColorStop(1,`rgba(${r},${gg},${b},0.0)`);
        ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(x,y,size*2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle=`rgb(${r},${gg},${b})`; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
      }
    }
  }

  // --- Audio heartbeat (unchanged) ---
  let audio={ctx:null,osc:null,gain:null}; function ensureAudio(){ if(audio.ctx){ if(audio.ctx.state==='suspended') audio.ctx.resume(); return; }
    const ctxA=new (window.AudioContext||window.webkitAudioContext)(); const osc=ctxA.createOscillator(); const gain=ctxA.createGain();
    osc.type='sine'; osc.frequency.value=60; gain.gain.value=0.0; osc.connect(gain).connect(ctxA.destination); osc.start(); if(ctxA.state==='suspended')ctxA.resume();
    audio={ctx:ctxA,osc,gain}; $('aust').textContent='on'; if($('mute').checked) gain.gain.setTargetAtTime(0.0, ctxA.currentTime, 0.05); else gain.gain.setTargetAtTime(0.12, ctxA.currentTime, 0.05);
  }
  $('mute').addEventListener('change',()=>{ if(!audio.ctx)return; const t=audio.ctx.currentTime; audio.gain.gain.setTargetAtTime($('mute').checked?0.0:0.12,t,0.05); $('aust').textContent=$('mute').checked?'off':'on'; });

  // --- Main loop ---
  let prev=performance.now(); let fpsA=0,fpsN=0,lastF=performance.now();
  function updateUBO(timeSec){
    const now=performance.now(); const dt=Math.max(0,(now-prev)*0.001); prev=now;

    FIELD_MAX_R = Math.max(JW_R*1.15, (+R_.value)*8.0);

    // camera behavior
    if (holoToggle.checked){
      const Rmaj=+R_.value, rmin=+r_.value;
      state.camPos=[Rmaj-0.6*rmin, 0.0, 0.0];
      const fwd=[1,0,0]; state.yaw=Math.atan2(-fwd[2],-fwd[0]); state.pitch=0;
    } else {
      if (autoOrbit){
        const {center: C, radius: B} = {center:JW_C, radius:Math.max(JW_R,(+R_.value + +r_.value*2.0))};
        const theta = (now*0.001*orbitSpeed)% (Math.PI*2);
        const x=C[0]+Math.cos(theta)*((B*1.35)/Math.tan(FOV*0.5));
        const z=C[2]+Math.sin(theta)*((B*1.35)/Math.tan(FOV*0.5));
        const y=C[1]+0.15*((B*1.35)/Math.tan(FOV*0.5));
        state.camPos=[x,y,z]; lookAt(state.camPos, C);
      }
      const kb=new Set(keys); const {forward,right}=camBasis(); let vel=[0,0,0];
      if(kb.has('w')) vel=add(vel,forward); if(kb.has('s')) vel=add(vel,[-forward[0],-forward[1],-forward[2]]);
      if(kb.has('a')) vel=add(vel,[-right[0],-right[1],-right[2]]); if(kb.has('d')) vel=add(vel,right);
      if(kb.has('q')) vel=add(vel,[0,-1,0]); if(kb.has('e')) vel=add(vel,[0, 1,0]); if(vel[0]||vel[1]||vel[2]) state.camPos=add(state.camPos, mul(norm(vel), 4.0*dt));
    }

    advect(dt);
    encodeBoundary();

    const {forward,right,up}=camBasis();
    const u=new Float32Array(UBO_SIZE/4);
    u.set([state.camPos[0],state.camPos[1],state.camPos[2], timeSec],0);
    u.set([forward[0],forward[1],forward[2], +exp_.value],4);
    u.set([right[0],right[1],right[2], +R_.value],8);
    u.set([up[0],up[1],up[2], +r_.value],12);
    const light=[3,4,-2]; u.set([light[0],light[1],light[2], +k_.value],16);
    u.set([+tilt_.value, +shift_.value, (projToggle.checked?1:0), (holoToggle.checked?1:0)],20);
    device.queue.writeBuffer(ubo,0,u.buffer,u.byteOffset,u.byteLength);
  }

  function frame(ts){
    const tSec=ts*0.001; updateUBO(tSec);

    const enc=device.createCommandEncoder();
    const pass=enc.beginRenderPass({ colorAttachments:[{view:ctx.getCurrentTexture().createView(), clearValue:{r:0.02,g:0.03,b:0.05,a:1}, loadOp:'clear', storeOp:'store'}] });
    if (showTorus.checked) { pass.setPipeline(pipeline); pass.setBindGroup(0, bindGroup); pass.draw(3,1,0,0); }
    pass.end();
    device.queue.submit([enc.finish()]);

    drawOverlay();

    const now=performance.now(); fpsA+=now-lastF; fpsN++; lastF=now; if(fpsA>500){ fpsEl.textContent=Math.round(1000*fpsN/fpsA); fpsA=0; fpsN=0; }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  const gfx=$('gfx'); gfx.addEventListener('click',ensureAudio); gfx.addEventListener('pointerdown',ensureAudio);
})();

document.getElementById('collapseBtn').addEventListener('click', () => {
  document.body.classList.toggle('collapsed');
});

</script>
</body>

</html>

